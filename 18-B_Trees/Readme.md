B-trees are balanced search trees designed to work well on disks or other directaccess secondary storage devices. B-trees are similar to red-black trees (Chapter 13), but they are better at minimizing disk I/O operations. Many database systems use B-trees, or variants of B-trees, to store information.

B-trees differ from red-black trees in that B-tree nodes may have many children, from a few to thousands. That is, the "branching factor" of a B-tree can be quite large, although it usually depends on characteristics of the disk unit used. B-trees are similar to red-black trees in that every $n$-node B-tree has height $O$ (Ig $n$ ). The exact height of a B-tree can be considerably less than that of a red-black tree, however, because its branching factor, and hence the base of the logarithm that expresses its height, can be much larger. Therefore, we can also use $\mathrm{B}$-trees to implement many dynamic-set operations in time $O(\lg n)$.

B-trees generalize binary search trees in a natural manner. Figure 18.1 shows a simple B-tree. If an internal B-tree node $x$ contains $x . n$ keys, then $x$ has $x . n+1$ children. The keys in node $x$ serve as dividing points separating the range of keys handled by $x$ into $x . n+1$ subranges, each handled by one child of $x$. When searching for a key in a B-tree, we make an $(x . n+1)$-way decision based on comparisons with the $x . n$ keys stored at node $x$. The structure of leaf nodes differs from that of internal nodes; we will examine these differences in Section 18.1.
Section 18.1 gives a precise definition of B-trees and proves that the height of a B-tree grows only logarithmically with the number of nodes it contains. Section 18.2 describes how to search for a key and insert a key into a B-tree, and Section 18.3 discusses deletion. Before proceeding, however, we need to ask why we evaluate data structures designed to work on a disk differently from data structures designed to work in main random-access memory.