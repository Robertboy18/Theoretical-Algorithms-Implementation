In previous chapters, we saw data structures that support the operations of a priority queue-binary heaps in Chapter 6 , red-black trees in Chapter $13,{ }^1$ and Fibonacci heaps in Chapter 19. In each of these data structures, at least one important operation took $O(\lg n)$ time, either worst case or amortized. In fact, because each of these data structures bases its decisions on comparing keys, the $\Omega(n \lg n)$ lower bound for sorting in Section 8.1 tells us that at least one operation will have to take $\Omega(\lg n)$ time. Why? If we could perform both the INSERT and EXTRACT-MIN operations in $o(\lg n)$ time, then we could sort $n$ keys in $o(n \lg n)$ time by first performing $n$ INSERT operations, followed by $n$ EXTRACT-MIN operations.

We saw in Chapter 8 , however, that sometimes we can exploit additional information about the keys to sort in $o(n \lg n)$ time. In particular, with counting sort we can sort $n$ keys, each an integer in the range 0 to $k$, in time $\Theta(n+k)$, which is $\Theta(n)$ when $k=O(n)$.

Since we can circumvent the $\Omega(n \lg n)$ lower bound for sorting when the keys are integers in a bounded range, you might wonder whether we can perform each of the priority-queue operations in $o(\lg n)$ time in a similar scenario. In this chapter, we shall see that we can: van Emde Boas trees support the priority-queue operations, and a few others, each in $O(\lg \lg n)$ worst-case time. The hitch is that the keys must be integers in the range 0 to $n-1$, with no duplicates allowed.

Specifically, van Emde Boas trees support each of the dynamic set operations listed on page 230-SEARCH, INSERT, DELETE, MINIMUM, MAXIMUM, SUCCESSOR, and PREDECESSOR - in $O(\lg \lg n)$ time. In this chapter, we will omit discussion of satellite data and focus only on storing keys. Because we concentrate on keys and disallow duplicate keys to be stored, instead of describing the SEARCH operation, we will implement the simpler operation $\operatorname{MEMBER}(S, x)$, which returns a boolean indicating whether the value $x$ is currently in dynamic set $S$.

So far, we have used the parameter $n$ for two distinct purposes: the number of elements in the dynamic set, and the range of the possible values. To avoid any further confusion, from here on we will use $n$ to denote the number of elements currently in the set and $u$ as the range of possible values, so that each van Emde Boas tree operation runs in $O(\lg \lg u)$ time. We call the set $\{0,1,2, \ldots, u-1\}$ the universe of values that can be stored and $u$ the universe size. We assume throughout this chapter that $u$ is an exact power of 2 , i.e., $u=2^k$ for some integer $k \geq 1$

Section 20.1 starts us out by examining some simple approaches that will get us going in the right direction. We enhance these approaches in Section 20.2, introducing proto van Emde Boas structures, which are recursive but do not achieve our goal of $O(\lg \lg u$ )-time operations. Section 20.3 modifies proto van Emde Boas structures to develop van Emde Boas trees, and it shows how to implement each operation in $O(\lg \lg u)$ time.